apiVersion: v1
kind: ServiceAccount
metadata:
  name: mysql-failover-watcher
  namespace: default
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: mysql-failover-role
  namespace: default
rules:
  - apiGroups: [""]
    resources: ["services", "endpoints", "pods"]
    verbs: ["get", "patch", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: mysql-failover-binding
  namespace: default
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: mysql-failover-role
subjects:
  - kind: ServiceAccount
    name: mysql-failover-watcher
---
# Pod의 api-server 컨테이너로의 외부 접근을 위한 NodePort 서비스 추가
apiVersion: v1
kind: Service
metadata:
  name: failover-api-service
spec:
  type: NodePort
  selector:
    app: mysql-failover-watcher
  ports:
    - protocol: TCP
      port: 8080       # 클러스터 내부에서 사용할 포트
      targetPort: 8080 # Pod의 api-server 컨테이너가 리스닝할 포트
      nodePort: 30888  # 외부에서 접근할 NodePort
---
# ServiceAccount, Role, RoleBinding, Service 등 다른 부분은 모두 이전과 동일합니다.
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql-failover-watcher
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql-failover-watcher
  template:
    metadata:
      labels:
        app: mysql-failover-watcher
    spec:
      hostNetwork: true
      serviceAccountName: mysql-failover-watcher
      volumes:
        - name: state-volume
          emptyDir: {}
        # kubectl 바이너리를 공유하기 위한 볼륨 추가
        - name: bin-volume
          emptyDir: {}
      
      # Pod 시작 전 kubectl을 다운로드하는 initContainer
      initContainers:
        - name: kubectl-downloader
          image: alpine:latest
          command:
            - /bin/sh
            - -c
            - |
              # curl 설치 후 kubectl 다운로드 및 권한 설정
              apk update && apk add curl
              curl -LO "https://dl.k8s.io/release/v1.29.0/bin/linux/amd64/kubectl"
              chmod +x kubectl
              # 공유 볼륨으로 이동
              mv kubectl /shared-bin/
          volumeMounts:
            - name: bin-volume
              mountPath: /shared-bin

      containers:
        # alpine 이미지 사용 및 공유된 kubectl 실행
        - name: kubectl-watcher
          image: alpine:latest
          volumeMounts:
            - name: state-volume
              mountPath: /state
            - name: bin-volume
              mountPath: /shared-bin
          command:
            - /bin/sh
            - -c
            - |
              PREV_LOG_MSG=""
              echo "$(date '+%Y-%m-%d %H:%M:%S') [Watcher] Starting failover watcher."
              echo "active" > /state/state
              while true; do
                EP_ACTIVE=$(/shared-bin/kubectl get pods -l app=mysql-active -o jsonpath='{.items[?(@.status.containerStatuses[0].ready==true)]}' | wc -w)
                CURRENT_SELECTOR=$(/shared-bin/kubectl get svc mysql-active-service -o jsonpath='{.spec.selector.app}')
                if [ -z "$CURRENT_SELECTOR" ]; then
                  echo "$(date '+%Y-%m-%d %H:%M:%S') [Watcher] WARN: mysql-active-service not found. Retrying..."
                  sleep 15
                  continue
                fi
                if [ -f /state/recover_command ]; then
                  echo "$(date '+%Y-%m-%d %H:%M:%S') [Recovery] EVENT: Received recovery command."
                  if [ "$EP_ACTIVE" -gt 0 ]; then
                    if [ "$CURRENT_SELECTOR" = "mysql-standby" ]; then
                       echo "$(date '+%Y-%m-%d %H:%M:%S') [Recovery] EVENT: Active pod is ready. Recovering to active..."
                       /shared-bin/kubectl patch svc mysql-active-service --type=json -p "[{\"op\":\"replace\",\"path\":\"/spec/selector/app\",\"value\":\"mysql-active\"}]"
                       echo "active" > /state/state
                    else
                       echo "$(date '+%Y-%m-%d %H:%M:%S') [Recovery] INFO: Already in active state. No action needed."
                    fi
                  else
                    echo "$(date '+%Y-%m-%d %H:%M:%S') [Recovery] WARN: Recovery failed. Active pod is not ready yet."
                  fi
                  rm /state/recover_command
                elif [ "$EP_ACTIVE" -lt 1 ] && [ "$CURRENT_SELECTOR" = "mysql-active" ]; then
                  echo "$(date '+%Y-%m-%d %H:%M:%S') [Failover] EVENT: Active pod is down. Failing over to standby..."
                  /shared-bin/kubectl patch svc mysql-active-service --type=json -p "[{\"op\":\"replace\",\"path\":\"/spec/selector/app\",\"value\":\"mysql-standby\"}]"
                  echo "standby" > /state/state
                fi
                CURRENT_LOG_MSG="[Watcher] State: $(cat /state/state), Service selector: ${CURRENT_SELECTOR}, ActiveReady: ${EP_ACTIVE}"
                if [ "$CURRENT_LOG_MSG" != "$PREV_LOG_MSG" ]; then
                  echo "$(date '+%Y-%m-%d %H:%M:%S') ${CURRENT_LOG_MSG}"
                  PREV_LOG_MSG="$CURRENT_LOG_MSG"
                fi
                sleep 15
              done
        
        # alpine 이미지 사용, python3 설치 후 서버 실행 및 공유된 kubectl 사용
        - name: api-server
          image: alpine:latest
          volumeMounts:
            - name: state-volume
              mountPath: /state
            - name: bin-volume
              mountPath: /shared-bin
          command:
            - /bin/sh
            - -c
            - |
              # python3 설치
              apk update && apk add python3
              
              # 파이썬 웹서버 실행
              python3 -c '
              import http.server
              import socketserver
              import json
              import subprocess
              import os

              PORT = 8080
              KUBECTL_PATH = "/shared-bin/kubectl"

              class FailoverApiHandler(http.server.SimpleHTTPRequestHandler):
                  def do_GET(self):
                      response_body = {}
                      status_code = 200
                      
                      if self.path == "/status":
                          try:
                              selector_proc = subprocess.run(
                                  [KUBECTL_PATH, "get", "svc", "mysql-active-service", "-o", "jsonpath={.spec.selector.app}"],
                                  capture_output=True, text=True, check=True
                              )
                              current_selector = selector_proc.stdout.strip()
                              
                              try:
                                  with open("/state/state", "r") as f:
                                      internal_state = f.read().strip()
                              except FileNotFoundError:
                                  internal_state = "unknown"
                              
                              response_body = {
                                  "service_target": current_selector,
                                  "watcher_state": internal_state
                              }
                          except Exception as e:
                              status_code = 500
                              response_body = {"error": str(e)}

                      elif self.path == "/recover":
                          try:
                              with open("/state/recover_command", "w") as f:
                                  f.write("recover")
                              response_body = {"message": "Recovery command issued."}
                          except Exception as e:
                              status_code = 500
                              response_body = {"error": str(e)}
                      else:
                          status_code = 404
                          response_body = {"error": "Not Found", "path_detected": self.path}
                          
                      self.send_response(status_code)
                      self.send_header("Content-type", "application/json")
                      self.end_headers()
                      self.wfile.write(json.dumps(response_body).encode("utf-8"))

              with socketserver.TCPServer(("", PORT), FailoverApiHandler) as httpd:
                  print("Python API server started at port", PORT)
                  httpd.serve_forever()
              '

        # conntrack-watcher
        - name: conntrack-watcher
          image: docker.io/nicolaka/netshoot:latest
          securityContext:
            capabilities:
              add: ["NET_ADMIN"]
          volumeMounts:
            - name: state-volume
              mountPath: /state
          command:
            - /bin/sh
            - -c
            - |
              PREV_FILE_STATE=""
              while true; do
                if [ -f /state/state ]; then
                  CUR_STATE=$(cat /state/state)
                  if [ "$CUR_STATE" != "$PREV_FILE_STATE" ]; then
                    conntrack -D -p tcp --dport 32306
                    echo "$(date '+%Y-%m-%d %H:%M:%S') Flushed conntrack for 32306 (state=${CUR_STATE})"
                  fi
                  PREV_FILE_STATE="$CUR_STATE"
                fi
                sleep 5
              done